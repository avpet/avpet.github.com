<!DOCTYPE html>
<html>
<head>
    <title>Алгоритм Брезенхэма (Bresenham) - 1</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="bresenham.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <meta property="og:image" content="images/logo.png">
    <link rel="stylesheet" href="/css/main.css">
</head>
<body>

<script type="text/javascript" src="./javascript/algorithm-visualization-opt.js"></script>
<script>
    com.avpet.algoviz.bresenham.BresenhamUI().main();
</script>

<div class="page-content">
      <div class="wrapper">
        <div class="post">


  <article class="post-content">
    <style>
/* To center images */
.center {
    text-align: center;
}

.wrapper {
    margin-left: auto;
    margin-right: auto;
    max-width: calc(1200px - 30px * 2);
    padding-left: 30px;
    padding-right: 30px;
}
</style>

<p>Несмотря на всю сложность компьютерной графики, в ее основе лежит на удивление небольшое количество простых функций. Наиболее часто используемые графические функции-примитивы - рисование точки, окружностей, заливка областей, копирование блоков данных о цвете, и, конечно, рисование отрезков прямых. Последняя функция часто поддерживается в том числе и на аппаратном уровне.</p>

<p>Наверное, наиболее известный алгоритм, используемый для рисования прямых на растровом устройстве - это алгоритм Брезенхэма. Алгоритм Брезенхэма определяет, какие точки двумерного растра нужно закрасить, чтобы получить близкое приближение прямой линии между двумя заданными точками. Это один из старейших алгоритмов в машинной графике &mdash; он был разработан Джеком Элтоном Брезенхэмом (Jack Elton Bresenham) в компании IBM в 1962 году. Алгоритм Брезенхэма очень эффективен, поскольку не требует операций с числами с плавающей запятой, не требует деления, и довольно компактен.</p>

<p class="center"><img src="http://imgur.com/3oN7V04.png" alt="gras"></p>

<p>В основе алгоритма Брезенхэма лежит идея, что для того, при изображении приближенного представления прямой с помощью конечного числа пикселей, часть пикселей будет лежать непосредственно на этой прямой, а часть немного в стороне, хотя и в непосредственной близости от этой прямой. Отклонение данного пикселя от аппроксимируемой прямой называется погрешностью. 
Рассмотрим случай, где горизонтальная длина отрезка прямой X больше, чем вертикальная Y. Например, предположим, что мы рисуем отрезок от (0,0) к (5,2), как изображено ниже. Концы отрезка совпадают с центрами указанных пикселей. Однако, в остальном отрезок не пересекает ни один из центров промежуточных пикселей, а это значит, что остальные пиксели будут аппроксимировать отрезок. Подход, используемый алгоритмом Брезенхэма, состоит в том, чтобы, рисуя новый пиксель, смещаться на один пиксель вдоль большей стороны (например, в данном случае вдоль X), и смещаться вдоль меньшей стороны (Y в данном случае), если мы отклоняемся от прямой на расстояние, большее чем половина расстояния между пикселями.</p>

<p class="center"><img src="http://imgur.com/jCfvkEd.png" alt="gras"></p>

<p>Для того, чтобы следить за отклонением, нужно хранить и обновлять значение погрешности - т.е. насколько далеко мы отклонились по Y в данной координате, как показано ниже. Если мы обнаруживаем, что отклонение по Y привело к тому, что существует еще одна, более близкая координата по Y, чем текущая, то мы должны выбрать Y этой более близкой координаты в качестве текущей. Давайте проследим более детально на иллюстрации ниже, как именно будет вести себя алгоритм Брезенхэма. Начальный пиксель мы рисуем в позиции (0,0), стартовой точке отрезка. На этом этапе погрешность равна 0.</p>

<p>Поскольку X в данном случае является большей стороной, то следующий пиксель будет иметь кооринату X=1. Координата Y следующей точки будет либо равна 0 (как и в предыдущей точке), либо 1 - в зависимости от того, какая их них ближе. В этом случае погрешнсть будет равна B - A. Чисто визуально можно заметить, что погрешность меньше, чем 1/2 расстояния между пикселями, так что коорлината Y не меняется при X=1, и мы рисуем следующий пиксель.</p>

<p>Третий пиксель имеет координату X = 2. Здесь погрешность уже равна C - A, что, очевидно, превышает 1/2 расстояния между пикселями, и значит, что следующий пиксель мы рисуем в (2,1), а 1 отнимается от погрешности для того, чтобы учесть, что мы сдвинулись на 1 по Y. В этой точке погрешность равна C - D.</p>

<p class="center"><img src="http://imgur.com/4SZpU7y.png" alt="gras"></p>

<p>Четвертый пиксель имеет координату X = 3. Погрешность здесь равна E - D; поскольку это менее 1/2 межпиксельного расстояния, то Y мы не меняем. Четвертый пиксель рисуем в позиции (3,1).</p>

<p>Пятый пиксель находится имеет координату X=4. Погрешность здесь уже F - D, что превышает 1/2 межпиксельного расстояния, Y снова увеличивается на 1. Третий пиксель - в точке (4,2), и мы отнимаем 1 от погрешности. которая здесь уже составляет G - F.</p>

<p>И, наконец, шестой пиксель является конечной точкой отрезка. У этого пикселя координата X = 5. Погрешность здесь равна G - G, или 0, что означает, что точка нахолиться на исходной прямой.</p>

  </article>

</div>

      </div>
<p>Источники:</p>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm</a></li>
  <li><a href="https://www.amazon.com/Michael-Abrashs-Graphics-Programming-Special/dp/1576101746">https://www.amazon.com/Michael-Abrashs-Graphics-Programming-Special/dp/1576101746</a></li>
  <li><a href="http://stackoverflow.com/questions/4672279/bresenham-algorithm-in-javascript">http://stackoverflow.com/questions/4672279/bresenham-algorithm-in-javascript</a></li>
</ul>

      </div>
</body>
</html>
