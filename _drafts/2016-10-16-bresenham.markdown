---
layout: post
title:  "Алгоритм Брезенхэма (Bresenham)"
date:   2016-10-16 11:30:00
categories: scala
image: http://imgur.com/GKpGAWa.jpg
---
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
/* To center images */
.center {
    text-align: center;
}

.MathJax_Display {
  text-align: left !important;
}
</style>

Источники:

* [https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)
* [https://www.amazon.com/Michael-Abrashs-Graphics-Programming-Special/dp/1576101746](https://www.amazon.com/Michael-Abrashs-Graphics-Programming-Special/dp/1576101746)
* [http://stackoverflow.com/questions/4672279/bresenham-algorithm-in-javascript](http://stackoverflow.com/questions/4672279/bresenham-algorithm-in-javascript)

# Алгоритм Брезенхэма

Несмотря на всю сложность компьютерной графики, в ее основе лежит на удивление небольшое количество простых функций. Наиболее часто используемые графические функции-примитивы - рисование точки, окружностей, заливка областей, копирование блоков данных о цвете, и, конечно, рисование отрезков прямых. Последняя функция часто поддерживается в том числе и на аппаратном уровне.

Наверное, наиболее известный алгоритм, используемый для рисования прямых на растровом устройстве - это алгоритм Брезенхэма. Алгоритм Брезенхэма определяет, какие точки двумерного растра нужно закрасить, чтобы получить близкое приближение прямой линии между двумя заданными точками. Это один из старейших алгоритмов в машинной графике — он был разработан Джеком Элтоном Брезенхэмом (Jack Elton Bresenham) в компании IBM в 1962 году. Алгоритм Брезенхэма очень эффективен, поскольку не требует операций с числами с плавающей запятой, не требует деления, и довольно компактен.

{: .center}
![gras](http://imgur.com/3oN7V04.png)

В основе алгоритма Брезенхэма лежит идея, что для того, при изображении приближенного представления прямой с помощью конечного числа пикселей, часть пикселей будет лежать непосредственно на этой прямой, а часть немного в стороне, хотя и в непосредственной близости от этой прямой. Отклонение данного пикселя от аппроксимируемой прямой называется погрешностью. 
Рассмотрим случай, где длина горизонтальной проекции отрезка прямой *X* больше, чем вертикальная *Y*. Например, предположим, что мы рисуем отрезок от *(0,0)* к *(5,2)*, как изображено ниже. Концы отрезка совпадают с центрами указанных пикселей. Однако, в остальном отрезок не пересекает ни один из центров промежуточных пикселей, а это значит, что остальные пиксели будут аппроксимировать отрезок. Подход, используемый алгоритмом Брезенхэма, состоит в том, чтобы, рисуя новый пиксель, смещаться на один пиксель вдоль оси с большей длиной проекции отрезка (например, в данном случае вдоль *X*), и смещаться вдоль оси с меньшей длиной проекции отрезка (*Y* в данном случае), если мы отклоняемся от прямой на расстояние, большее чем половина расстояния между пикселями.

{: .center}
![gras](http://imgur.com/jCfvkEd.png)

Для того, чтобы следить за отклонением, нужно хранить и обновлять значение погрешности - т.е. насколько далеко мы отклонились по *Y* в данной координате, как показано ниже. Если мы обнаруживаем, что отклонение по *Y* привело к тому, что существует еще одна, более близкая координата по *Y*, чем текущая, то мы должны выбрать *Y* этой более близкой координаты в качестве текущей. Давайте проследим более детально на иллюстрации ниже, как именно будет вести себя алгоритм Брезенхэма. Начальный пиксель мы рисуем в позиции (0,0), стартовой точке отрезка. На этом этапе погрешность равна 0.

Поскольку длина проекции отрезка на ось *X* в данном случае является больше, то следующий пиксель будет иметь координату *X=1*. Координата *Y* следующей точки будет либо равна 0 (как и в предыдущей точке), либо 1 - в зависимости от того, какая их них ближе. В этом случае погрешность будет равна *B - A*. Чисто визуально можно заметить, что погрешность меньше, чем 1/2 расстояния между пикселями, так что координата *Y* не меняется при *X=1*, и мы рисуем следующий пиксель.

Третий пиксель имеет координату *X = 2*. Здесь погрешность уже равна *C - A*, что, очевидно, превышает 1/2 расстояния между пикселями, и значит, что следующий пиксель мы рисуем в *(2,1)*, а *1* отнимается от погрешности для того, чтобы учесть, что мы сдвинулись на *1* по *Y*. В этой точке погрешность равна *C - D*. 

{: .center}
![gras](http://imgur.com/4SZpU7y.png)

Четвертый пиксель имеет координату *X = 3*. Погрешность здесь равна *E - D*; поскольку это менее 1/2 межпиксельного расстояния, то *Y* мы не меняем. Четвертый пиксель рисуем в позиции (3,1).

Пятый пиксель находится имеет координату *X=4*. Погрешность здесь уже *F - D*, что превышает 1/2 межпиксельного расстояния, *Y* снова увеличивается на 1. Третий пиксель - в точке (4,2), и мы отнимаем 1 от погрешности. которая здесь уже составляет *G - F*.

И, наконец, шестой пиксель является конечной точкой отрезка. У этого пикселя координата *X = 5*. Погрешность здесь равна G - G, или 0, что означает, что точка находиться на исходной прямой. 

Попробуем записать это в виде формул и затем - кода. Запишем конечную и начальную точки (0,0) и (5,2) отрезка как $$(x0, y0)$$ и $$(x1, y1)$$. Причем *x* растет вниз, *y* - вправо (так обычно устроена экранная система координат).

Таким образом, в нашем случае длина горизонтальной проекции $$x1 - x0$$ и длина вертикальной проекции $$y1 - y0$$, причем длина горизонтальной проекции отрезка больше вертикальной, то есть наклон линии от горизонтали — менее 45°. Наша цель состоит в том, чтобы для каждого столбца *x* между $$x0$$ и $$x1$$ определить, какая строка y ближе всего к линии, и нарисовать точку $$(x , y)$$.

Общая формула линии между двумя точками:

$$ y=\frac{y1-y0}{x1-x0}(x-x0) $$

Поскольку мы знаем колонку *x*, то строка *y* получается округлением к целому следующего значения:

$$ y=\frac{y1-y0}{x1-x0}(x-x0) + y0 $$

Однако, вычислять точное значение этого выражения нет необходимости. Достаточно заметить, что $$y$$ уменьшается от $$y0$$ и за каждый шаг мы добавляем к $$x$$ единицу и добавляем к $$y$$ значение наклона (в нашем случае значение наклона будет отрицательным числом):

$$ s=\frac{y1-y0}{x1-x0} $$

которое можно вычислить заранее. Более того, на каждом шаге мы делаем одно из двух: либо сохраняем тот же *y*, либо уменьшаем его на *1*.

Что из этих двух выбрать — можно решить, отслеживая значение погрешности, которое означает — вертикальное расстояние между текущим значением *y* и точным значением *y* для текущего *x*. Всякий раз, когда мы увеличиваем *x*, мы увеличиваем значение ошибки на величину наклона *s*, приведённую выше. Если ошибка превысила *0.5*, линия стала ближе к следующему *y*, поэтому мы уменьшаем *y* на единицу, одновременно уменьшая значение ошибки на *1*.

Ниже приведена реализация функции для аппроксимирования линии пикселями на Scala, полностью же реализация с отрисовкой находится [здесь](https://github.com/avpet/algorithm-visualization/tree/master/src/main/scala/com/avpet/algoviz/bresenham)

{% highlight scala %}
  private def bresenham(ctx: CanvasContext, x0: Int, y0: Int, x1: Int, y1: Int) = {
    var x = x0
    var y = y0
    val dx = Math.abs(x1 - x0)
    val dy = Math.abs(y1 - y0)
    val sx = if (x0 < x1) 1 else -1
    val sy = if (y0 < y1) 1 else -1
    var err = dx - dy

    def it = new Iterator[Point] {
      def next = {
        val p = Point(x, y)

        val e2 = 2 * err
        if (e2 > -dy) {
          err -= dy
          x += sx
        }
        if (e2 < dx) {
          err += dx
          y += sy
        }
        p
      }

      def hasNext = !((x == x1) && (y == y1))
    }

    for (p <- it) drawPixel(ctx, p.x, p.y, "black")
  }
{% endhighlight %}

