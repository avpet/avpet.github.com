---
layout: post
title:  "Жизненнный цикл и мониторинг акторов"
date:   2015-11-22 06:30:00
categories: scala
image: http://i.imgur.com/yHXn1A6.png
reactive-stock-src: https://github.com/typesafehub/reactive-stocks/blob/master/
---

<style>
/* To center images */
.center {
    text-align: center;
}
</style>

### Жизненнный цикл и мониторинг акторов ###

#### Анатомия актора ####

Как известно, модель акторов является высокоуровневой абстракцией для создания параллельных приложений. Она освобождает разработчика от необходимости явно управлять блокировками и потоками. Как показано ниже, актор состоит из нескольких взаимодействующих элементов. `ActorRef` представляет собой логический адрес актора и позволяет нам асинхронно посылать сообщения актору, т.е. не дожидаясь отклика. Dispatcher (диспетчер) – по умолчанию обычно есть 1 dispatcher на actor system – отвечает за постановку сообщений в очередь в mailbox'е актора, а также за scheduling извлечения сообщений из mailbox'а – причем только по одному за раз – для их последующей обработки в акторе. И наконец, актор, реализующий трейт Actor (собственно, это весь API, который мы должны реализовать) – инкапсулирует и состояние, и поведение.

{: .center}
![r5v1To1.png](http://i.imgur.com/r5v1To1.png)

Как мы увидим позднее, Akka не дает нам прямого доступа к Actor'у и таким образом обеспечивает то, что отправка асинхронных сообщений - единственный способ взаимодействия с актором: невозможно вызвать метод у актора. Также стоит заметить что отсылка сообщения актору и обработка этого сообщения актором - два совершенно разных действия, которые к тому же выполняются в разных потоках  – и разумеется, Akka обеспечивает всю необходимую синхронизацию целью защиты состояния актора. Следовательно, Akka как бы создает иллюзию однопоточности, т.е. нам не нужно заботится о синхронизации доступа к разделяемой памяти.

#### Реализация актора ####

В Akka актор - класс, который реализует трейт `Actor`:

{% highlight scala %}
class SimplestActor extends Actor {
  override def receive = Actor.emptyBehavior
}
{% endhighlight %}

Метод `receive` возвращает т.н. "исходное поведение" актора.  Каждый раз, когда нужно обработать сообщение, для сообщения ищется соотвествующий обработчик в текущем поведении актора. Поведение актора - функция, которая содержит ряд действий, которые нужно совершить в ответ на некоторые сообщения, например, адресовать запрос далее, если авторизация пройдена, или отклонить запрос в другом случае. Данное поведение может со временем измениться - например, клиенты, от которых приходят запросы, постепенно проходят авторизацию, или акторы могут входить в сотояние временной неработоспособности, а позднее опять начать обработку запросов. Эти изменения отражаются в переменных состояния; также сама функция может быть динамически заменена на другую - см. операции `become` и `unbecome`. Однако, исходное поведение, определенное в ходе создания актора, является специфическим в том смысле, что при перезапуске оно будет снова установлено для актора. В примере приведен простейший актор, не обрабатывающий никаких сообщений, т.к. частичная функция`Actor.emptyBehavior` не определена ни для одного значения.

В смысле реализации это просто частично определенная функция, вызываемая Аккой для обработки сообщений. Поскольку поведением является `PartialFunction[Any, Unit]`, по умолчанию невозможно определить актор, который принимает сообщения определеного типа. Существует, правда, т.н. модуль `akka-typed`, назначение которого - добавить безопасность типов в Akka, но он является все еще экспериментальным. 

#### Системы акторов и создание акторов ####

По выражению автора модели акторов Карла Хьюитта, “один актор не является актором, акторы работают в системе”. В Akka система акторов является совокупностью взаимодействующих акторов, их которых формируется иерархия - т.е. каждый актор  имеет актора-родителя. 


